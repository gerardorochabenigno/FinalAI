window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "source", "modulename": "source", "kind": "module", "doc": "<h1 id=\"proyecto-final-de-agentes-de-inteligencia-artificial-instituto-tecnologico-autonomo-de-mexico-itam-primavera-2025\">Proyecto Final de Agentes de Inteligencia Artificial, Instituto Tecnol\u00f3gico Aut\u00f3nomo de M\u00e9xico (ITAM), Primavera 2025</h1>\n\n<p><strong>Nombre: Gerardo Rocha Benigno (219932)</strong></p>\n\n<p><strong>Clave:  219932</strong></p>\n\n<p>Bienvenido a la documentaci\u00f3n de los modulos del proyecto <strong>Procesador OCR de Solicitudes Normativas y Generador de Respuestas</strong>.</p>\n\n<p>Este sistema permite:</p>\n\n<ul>\n<li>Recibir solicitudes de transparencia en formato imagen</li>\n<li>Aplicar OCR con Amazon Textract</li>\n<li>Limpiar y anonimizar el texto autom\u00e1ticamente</li>\n<li>Consultar normatividad relevante con RAG (ChromaDB + GPT)</li>\n<li>Generar respuestas en lenguaje formal, profesional y basado en evidencia normativa</li>\n</ul>\n\n<hr />\n\n<p><strong>Estructura del sistema</strong></p>\n\n<ul>\n<li><code>chroma_utils.py</code>: manejo de la base de datos ChromaDB</li>\n<li><code>config_loader.py</code>: manejo seguro de credenciales</li>\n<li><code>ocr_utils.py</code>: procesamiento de imagen y limpieza de texto</li>\n<li><code>rag_utils.py</code>: recuperaci\u00f3n de normativa y generaci\u00f3n de respuestas</li>\n<li><code>web_utils.py</code>: generaci\u00f3n de base de datos de normativa</li>\n</ul>\n"}, {"fullname": "source.chroma_utils", "modulename": "source.chroma_utils", "kind": "module", "doc": "<h1 id=\"descripcion\">Descripci\u00f3n</h1>\n\n<p>Este modulo contiene funciones para extraer texto y tablas de documentos PDF. Las tablas se convierten \nen texto legible con formato \"columna: valor\", y todo el contenido es dividido en fragmentos \nque se almacenan como embeddings en una colecci\u00f3n de ChromaDB.</p>\n\n<h1 id=\"funciones\">Funciones</h1>\n"}, {"fullname": "source.chroma_utils.tabla_a_texto", "modulename": "source.chroma_utils", "qualname": "tabla_a_texto", "kind": "function", "doc": "<p>Convierte una tabla extra\u00edda de un PDF en texto legible tipo \"columna: valor\".</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>tabla : list[list[str]]\n    Lista de listas que representa una tabla extra\u00edda con pdfplumber.\n    La primera sublista debe contener los encabezados.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Texto formateado de la tabla con pares \"encabezado: valor\", una fila por l\u00ednea.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tabla</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.chroma_utils.extraer_con_tablas", "modulename": "source.chroma_utils", "qualname": "extraer_con_tablas", "kind": "function", "doc": "<p>Extrae contenido textual y tabular de un archivo PDF combinando pdfplumber y pymupdf.</p>\n\n<p>La funci\u00f3n recorre cada p\u00e1gina del PDF especificado. Si la p\u00e1gina contiene una tabla\ncon m\u00e1s de una fila (para evitar tablas vac\u00edas o mal formateadas), esta se transforma \nen un bloque de texto legible tipo \"columna: valor\" mediante la funci\u00f3n <code>tabla_a_texto()</code>.\nSi no se detectan tablas, se extrae el texto plano de la p\u00e1gina usando pymupdf.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>ruta_pdf : str\n    Ruta al archivo PDF que se desea procesar.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Texto completo del documento, incluyendo tanto texto plano como\n    representaciones legibles de tablas, separado por saltos dobles de l\u00ednea.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ruta_pdf</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.chroma_utils.indexar_pdfs_en_chroma", "modulename": "source.chroma_utils", "qualname": "indexar_pdfs_en_chroma", "kind": "function", "doc": "<p>Indexa documentos PDF en una colecci\u00f3n ChromaDB con embeddings de texto.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>carpeta_pdfs : str\n    Ruta a la carpeta con archivos PDF a indexar.\npath_chroma : str\n    Ruta al almacenamiento persistente de ChromaDB.\nnombre_coleccion : str\n    Nombre de la colecci\u00f3n ChromaDB que se va a crear.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">carpeta_pdfs</span><span class=\"o\">=</span><span class=\"s1\">&#39;normatividad_compilado&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">path_chroma</span><span class=\"o\">=</span><span class=\"s1\">&#39;./chroma_data&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">nombre_coleccion</span><span class=\"o\">=</span><span class=\"s1\">&#39;normatividad&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.config_loader", "modulename": "source.config_loader", "kind": "module", "doc": "<h1 id=\"descripcion\">Descripci\u00f3n</h1>\n\n<p>Este m\u00f3dulo carga la configuraci\u00f3n de credenciales y par\u00e1metros desde un archivo YAML,\ny valida que est\u00e9n presentes los campos necesarios para conectarse a servicios externos\ncomo AWS y OpenAI.</p>\n\n<p>Funciones</p>\n"}, {"fullname": "source.config_loader.CONFIG_PATH", "modulename": "source.config_loader", "qualname": "CONFIG_PATH", "kind": "variable", "doc": "<p></p>\n", "default_value": "&#x27;config/config.yaml&#x27;"}, {"fullname": "source.config_loader.cargar_config", "modulename": "source.config_loader", "qualname": "cargar_config", "kind": "function", "doc": "<p>Carga la configuraci\u00f3n desde un archivo YAML.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>path : str\n    Ruta al archivo de configuraci\u00f3n (por defecto: \"config/config.yaml\").</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Diccionario con la configuraci\u00f3n cargada.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"o\">=</span><span class=\"s1\">&#39;config/config.yaml&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.config_loader.get_aws_credentials", "modulename": "source.config_loader", "qualname": "get_aws_credentials", "kind": "function", "doc": "<p>Obtiene las credenciales necesarias para conectarse a los servicios de AWS desde un archivo de configuraci\u00f3n local.</p>\n\n<p>Esta funci\u00f3n carga y valida que est\u00e9n presentes las siguientes claves en el archivo <code>config.yaml</code>:</p>\n\n<ul>\n<li>access_key_id</li>\n<li>secret_access_key</li>\n<li>region</li>\n</ul>\n\n<p>Si alguna de ellas no est\u00e1 definida, se lanza una excepci\u00f3n.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of str\n    Una tupla con tres elementos:\n    - access_key_id : str\n    - secret_access_key : str\n    - region : str</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>ValueError\n    Si alguna de las claves necesarias no se encuentra en la secci\u00f3n 'aws' del archivo de configuraci\u00f3n.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.config_loader.get_openai_key", "modulename": "source.config_loader", "qualname": "get_openai_key", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.ocr_utils", "modulename": "source.ocr_utils", "kind": "module", "doc": "<h1 id=\"descripcion\">Descripci\u00f3n</h1>\n\n<p>M\u00f3dulo para procesar im\u00e1genes o documentos con Amazon Textract (OCR avanzado).</p>\n\n<p>Permite extraer texto plano, pares clave-valor y tablas a partir de capturas, fotos o PDFs\nusando el servicio Textract de AWS.</p>\n\n<h1 id=\"funciones\">Funciones</h1>\n"}, {"fullname": "source.ocr_utils.corregir_ortografia", "modulename": "source.ocr_utils", "qualname": "corregir_ortografia", "kind": "function", "doc": "<p>Corrige ortograf\u00eda y redacci\u00f3n en espa\u00f1ol utilizando OpenAI GPT-4.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>texto : str\n    Texto limpio y anonimizado a corregir.\nmodel : str\n    Modelo de OpenAI (por defecto: \"gpt-4\").</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Texto corregido en redacci\u00f3n y ortograf\u00eda.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">texto</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;gpt-4&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.ocr_utils.extraer_texto_textract", "modulename": "source.ocr_utils", "qualname": "extraer_texto_textract", "kind": "function", "doc": "<p>Extrae texto plano desde un archivo (imagen o PDF) usando Amazon Textract.</p>\n\n<p>Esta funci\u00f3n se conecta al servicio Textract de AWS utilizando credenciales\nproporcionadas desde un archivo de configuraci\u00f3n. Puede manejar archivos \nlocales (ruta como string) o archivos en memoria (bytes).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>documento : str or bytes\n    Ruta al archivo en disco (por ejemplo, 'solicitud.pdf' o 'img.png'), \n    o contenido binario en memoria, como el que devuelve uploaded_file.read() en Streamlit.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Texto concatenado l\u00ednea por l\u00ednea, extra\u00eddo por Textract a partir del documento.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p>TypeError\n    Si el argumento 'documento' no es ni una ruta v\u00e1lida (str) ni un objeto binario (bytes).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">documento</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.ocr_utils.extraer_origen_y_titulo", "modulename": "source.ocr_utils", "qualname": "extraer_origen_y_titulo", "kind": "function", "doc": "<p>Extrae el origen (etiqueta entre corchetes) y el t\u00edtulo del correo a partir del texto OCR.</p>\n\n<p>Esta funci\u00f3n busca en el texto la primera l\u00ednea que contenga un patr\u00f3n tipo:\n\"[ORIGEN] t\u00edtulo del mensaje\", como suele encontrarse en encabezados de correos institucionales.\nSi no encuentra coincidencias, devuelve valores por defecto.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>texto : str\n    Texto completo extra\u00eddo por OCR, que incluye encabezado y cuerpo del correo.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple of str\n    Una tupla con dos elementos:\n    - origen : str\n        Etiqueta extra\u00edda entre corchetes (por ejemplo, \"TRANSPARENCIA\").\n    - titulo : str\n        Texto que sigue a la etiqueta, considerado como el t\u00edtulo del mensaje.\n        Si no se detecta patr\u00f3n, ambos valores ser\u00e1n: (\"Desconocido\", \"Sin t\u00edtulo detectado\").</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">texto</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.ocr_utils.limpiar_y_anonimizar", "modulename": "source.ocr_utils", "qualname": "limpiar_y_anonimizar", "kind": "function", "doc": "<p>Limpia el texto extra\u00eddo por OCR eliminando ruido visual, datos personales, encabezados duplicados\ny metadatos de interfaces de correo.</p>\n\n<p>Esta funci\u00f3n realiza una serie de transformaciones para mejorar la calidad del texto antes de pasarlo\nal modelo de correcci\u00f3n ortogr\u00e1fica. Entre otras cosas, elimina:</p>\n\n<ul>\n<li>Nombres y saludos comunes</li>\n<li>Correos electr\u00f3nicos, reemplaz\u00e1ndolos por [correo]</li>\n<li>Encabezados de correo repetidos (extra\u00eddos como origen y t\u00edtulo)</li>\n<li>Frases comunes de interfaz (e.g. \"Responder\", \"Reenviar\", \"Bloquear remitente\")</li>\n<li>Fechas, horarios y palabras muy cortas (ruido t\u00edpico del OCR)</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>texto : str\n    Texto plano extra\u00eddo por OCR.\norigen : str, optional\n    Origen del mensaje extra\u00eddo del encabezado (entre corchetes). Se usa para eliminar el encabezado redundante.\ntitulo : str, optional\n    T\u00edtulo extra\u00eddo del mensaje. Se usa junto con <code>origen</code> para eliminar encabezado duplicado.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Texto limpio y anonimizado, sin metadatos visuales, nombres ni formatos de correo electr\u00f3nico.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">texto</span>, </span><span class=\"param\"><span class=\"n\">origen</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">titulo</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.ocr_utils.generar_json_desde_correo", "modulename": "source.ocr_utils", "qualname": "generar_json_desde_correo", "kind": "function", "doc": "<p>Genera un diccionario JSON estructurado a partir del texto extra\u00eddo por OCR de una imagen o PDF.</p>\n\n<p>Esta funci\u00f3n:</p>\n\n<ul>\n<li>Extrae el origen y el t\u00edtulo del correo desde la primera l\u00ednea con formato [ORIGEN] T\u00cdTULO.</li>\n<li>Limpia el texto eliminando ruido visual, encabezados redundantes, correos y metadatos innecesarios.</li>\n<li>Corrige ortograf\u00eda y redacci\u00f3n del mensaje completo utilizando un modelo LLM (GPT-4).</li>\n<li>Devuelve un diccionario estructurado con los tres campos principales del mensaje.</li>\n</ul>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>texto_ocr : str\n    Texto crudo extra\u00eddo por OCR (usualmente desde Amazon Textract).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>dict\n    Diccionario con los siguientes campos:\n    - \"origen\": etiqueta entre corchetes que indica la fuente de la solicitud (por ejemplo, \"TRANSPARENCIA\").\n    - \"titulo\": texto que acompa\u00f1a al origen, sirve como resumen o asunto de la solicitud.\n    - \"mensaje\": cuerpo del mensaje corregido en ortograf\u00eda y redacci\u00f3n.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">texto_ocr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.rag_utils", "modulename": "source.rag_utils", "kind": "module", "doc": "<h1 id=\"descripcion\">Descripci\u00f3n</h1>\n\n<p>Este m\u00f3dulo se encarga de:</p>\n\n<ul>\n<li>Consultar una colecci\u00f3n ChromaDB con embeddings de fragmentos normativos de Banco de M\u00e9xico</li>\n<li>Recuperar fragmentos normativos relevantes</li>\n<li>Generar una respuesta con LLM (GPT-4) basada en el contexto y metadatos</li>\n<li>Formatear la respuesta de forma institucional usando un cat\u00e1logo de nombres legibles</li>\n</ul>\n\n<h1 id=\"funciones\">Funciones</h1>\n"}, {"fullname": "source.rag_utils.client", "modulename": "source.rag_utils", "qualname": "client", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;openai.OpenAI object&gt;"}, {"fullname": "source.rag_utils.chroma_client", "modulename": "source.rag_utils", "qualname": "chroma_client", "kind": "variable", "doc": "<p></p>\n", "default_value": "&lt;chromadb.api.client.Client object&gt;"}, {"fullname": "source.rag_utils.coleccion", "modulename": "source.rag_utils", "qualname": "coleccion", "kind": "variable", "doc": "<p></p>\n", "default_value": "Collection(name=normatividad)"}, {"fullname": "source.rag_utils.consultar_contexto_rag", "modulename": "source.rag_utils", "qualname": "consultar_contexto_rag", "kind": "function", "doc": "<p>Recupera los fragmentos m\u00e1s relevantes desde ChromaDB y extrae fuentes normativas.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mensaje_usuario : str\n    Pregunta del usuario corregida y limpia.\nk : int\n    N\u00famero de fragmentos a recuperar.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>tuple (contexto:str, fuentes:set)\n    Texto combinado de fragmentos relevantes y conjunto de nombres de normativas (source).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mensaje_usuario</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"o\">=</span><span class=\"mi\">10</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.rag_utils.normalizar_fuentes", "modulename": "source.rag_utils", "qualname": "normalizar_fuentes", "kind": "function", "doc": "<p>Reemplaza los nombres de archivo por t\u00edtulos legibles usando el cat\u00e1logo.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>fuentes : set\n    Conjunto de nombres de archivo PDF</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list[str]\n    Lista de nombres legibles de normatividad</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">fuentes</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.rag_utils.generar_respuesta_con_contexto", "modulename": "source.rag_utils", "qualname": "generar_respuesta_con_contexto", "kind": "function", "doc": "<p>Genera una respuesta normativa profesional basada en los fragmentos recuperados y fuentes legales.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mensaje_usuario : str\n    Solicitud del usuario (ya corregida).\ncontexto : str\n    Texto combinado de fragmentos normativos.\nfuentes : set\n    Conjunto de nombres de normativas (archivo fuente).\nmodel : str\n    Modelo de lenguaje a utilizar (por defecto: gpt-3.5-turbo).</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Respuesta generada por el modelo en estilo institucional.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mensaje_usuario</span>, </span><span class=\"param\"><span class=\"n\">contexto</span>, </span><span class=\"param\"><span class=\"n\">fuentes</span>, </span><span class=\"param\"><span class=\"n\">model</span><span class=\"o\">=</span><span class=\"s1\">&#39;gpt-3.5-turbo&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.rag_utils.responder_desde_json", "modulename": "source.rag_utils", "qualname": "responder_desde_json", "kind": "function", "doc": "<p>Flujo completo: dado un JSON generado por el OCR, recupera contexto y genera la respuesta.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>json_correo : dict\n    Diccionario con las claves: 'origen', 'titulo', 'mensaje'</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>str\n    Respuesta normativa completa generada con ayuda de contexto.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">json_correo</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "source.web_utils", "modulename": "source.web_utils", "kind": "module", "doc": "<h1 id=\"descripcion\">Descripci\u00f3n</h1>\n\n<p>Este m\u00f3dulo automatiza la descarga de documentos regulatorios agrupados por sujeto,\ny filtra \u00fanicamente aquellos que contienen la expresi\u00f3n 'texto compilado' en su contenido,\npreservando \u00fanicamente los documentos relevantes para an\u00e1lisis normativo.</p>\n\n<h1 id=\"funciones\">Funciones</h1>\n"}, {"fullname": "source.web_utils.descargar_normatividad_compilada", "modulename": "source.web_utils", "qualname": "descargar_normatividad_compilada", "kind": "function", "doc": "<p>Descarga los documentos de normatividad desde la p\u00e1gina de Banxico y conserva solo aquellos que contienen 'texto compilado'.\nEl texto compilado contiene la versi\u00f3n m\u00e1s reciente de la normatividad, por lo que es importante conservarlo.\nLos dem\u00e1s documentos no nos interesan porque contienen texto repetido o que ya no es relevante debido a que puede haber que ya no son vigentes.</p>\n\n<h2 id=\"params\">Params</h2>\n\n<p>destino : str\n    Carpeta donde se guardar\u00e1n los PDFs con texto compilado.\ncarpeta_temp : str\n    Carpeta temporal donde se descargan todos los PDFs antes de filtrar.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>list[str]\n    Lista de archivos que fueron conservados como 'texto compilado'.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">destino</span><span class=\"o\">=</span><span class=\"s1\">&#39;normatividad_compilado&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">carpeta_temp</span><span class=\"o\">=</span><span class=\"s1\">&#39;normatividad_completo&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();